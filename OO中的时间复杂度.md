# 浅谈OO中时间复杂度的考虑

在很多情况下，时间复杂度是衡量代码效率的重要指标。在面向对象的编程中，我们也需要考虑时间复杂度的问题。

然而，第一单元表达式解析中基本不需要考虑时间的问题，第二单元多线程电梯虽然要考虑时间，但也只是针对电梯调度和运行等问题上的优化，并不涉及时间复杂度的分析。

直到第三单元，单元的主体代码是实现图论相关的算法，需要我们维护一张关系图，支持更改和查询其中的一些信息。考虑到题目的数据量偏大，这里便需要分析考虑每个操作的时间复杂度，并据此来设计算法。

## 严格的时间复杂度？

参加过算法竞赛的同学应该普遍对于时间复杂度的概念比较敏感，在算法竞赛中考虑的时间复杂度通常是 **最坏时间复杂度**，因为出题人会设计各种极端情况来保证选手代码做法的严格正确性。

但在实际应用中则并不是这样，我们更多的可能是关心 **平均时间复杂度**。这是因为实际应用中的数据往往不会总是最坏情况，而是符合一定的分布，平均时间复杂度能够更好地反映算法在实际应用中的性能。并且，对于一些小的优化，也许对代码的时间复杂度并不会有任何影响，但是在实际应用中往往能起到一定的优化效果。

在OO这一单元的任务中，这个问题得到了很好的体现。

获取了数据范围后我们发现，最多会有 $10^4$ 次操作，而图上的点和边是通过操作慢慢进行添加的，查询操作的复杂度往往也只与点数和边数有关。对于这个数据范围我做了如下的考虑：假设极端情况下有 $5\times10^3$ 个点和 $5\times10^3$ 条边，有 $5\times10^3$ 次查询操作（这个情况显然超出了数据范围，但这样能够帮助我们对最坏的时间复杂度进行分析），一般而言时间复杂度为 $O(N^2)$ 的算法可以在 1s 内跑完大小为 $3\times10^3$ 的数据，那么我有 10s，$O(N^2)$ 的算法理论上可以跑完大小为 $5\times10^3$ 的数据，也即可以完美的完成这次作业。

那么理论上哪怕我所有操作都采用时间复杂度为 $O(N)$ 的实现，都可以通过评测。但真的是这样吗？考虑到 java 代码的运行效率本就远慢于 C/C++，以及常数问题，这样做还是有一定风险（不确定到底是否会强测 TLE，因为我没试也不敢试 qwq）。那么，是否又要考虑把所有操作的时间复杂度都降到 $O(N)$ 以下呢？首先这基本无法做到，其次也并没有必要。因为有很多操作的时间复杂度都是低于 $O(N)$ 的，或者操作时的 "N" 比较小（也即常数小）等等，综合到一起，虽然严格的时间复杂度仍然是 $O(N^2)$ 的，只看这个严格的时间复杂度，可能会得出无法通过评测的结论，但实际上还是可以跑得很快，很好的通过强测。

那么，我们的结论是：首先我们需要严格保证每次操作的时间复杂度不能超过 $O(N)$，这是最最基础与关键的；其次，即使一个操作的时间复杂度是 $O(N)$ 的，但我们要尽可能的让它的常数减小。打个比方，如果一张图在两次查询之间没有过加点或加边，那第二次查询时我完全没有必要再 $O(N)$ 算一遍，我可以直接给出结果。这种小优化在算法题里甚至不能被称之为优化，不会起到什么效果，也不会有人这样写；然而在实际应用中，它有的时候确实能起到作用，但如果陷入到写算法题的思维中，往往会忽视这些小地方。

得出了关于时间复杂度的结论后，我们便可以对每个操作的实现有一个大致的思路了。借此机会，也分享两次作业中一些关键查询操作中我的实现思路。

## 实现思路

### isCircle

判断两个人是否在一个连通块中，我选择直接 dfs。

### queryBlockSum

dfs 整张图即可，这里由于感觉每次都 dfs 开销有点大，我加了一个查询后只在加边和删边之后才重新计算。

### queryTripleSum

这个操作显然是不能直接枚举或者是 dfs 两层的，时间复杂度不对。考虑维护这个信息。我们在加边的时候，考虑新边的两个端点，新增的 triple 数量其实是两个端点的邻居集合的交集，删边的时候同理，triple 数量会减少这么多。这样，虽然加边和删边的复杂度变成了 $O(N)$ 的，但是把查询 TripleSum 的复杂度降到了 $O(1)$ 的，这是我们乐意看到的。

### queryTagValueSum

朴素算法需要 $O(N^2)$ 遍历，显然是不行的。考虑维护这个信息：往 tag 里加人的时候 $O(N)$ 扫一遍 tag 里的人维护；加边删边的时候 $O(N)$ 遍历所有 tag，看一下这条边是否对 tag 有影响，即边上的两个人是不是在同一个 tag 里（有想过维护每个人当前都被哪些 tag 所拥有，不过感觉意义不大就没有实现）。

### queryTagAgeVar

维护 tag 里的年龄均值与方差，实际上维护年龄的和与平方和就行了（展开一下式子），就可以做到 $O(1)$ 维护 $O(1)$ 查询。不过理论上 $O(N)$ 查询也没啥问题...

### queryBestAcquaintance

这个方法朴素的实现是 $O(N)$ 的，然而在 queryCoupleSum 方法中需要调用 $N$ 次这个方法，因此需要让这个查询复杂度为 $O(1)$。一开始写了在加边时 $O(1)$ 维护，删边时 $O(N)$ 维护，理论上复杂度也没错，后来改成了用大根堆存边，每次加边时 $O(\log N)$ 插入堆，删边不管，查询的时候先看堆顶的边是否还存在，如果不存在就 pop 掉，直到堆顶的边存在或堆为空。这个操作虽然看似复杂度比较大（有可能单次查询的时候堆里很多很多边都已经不存在了），但实际上它不会一直很大，复杂度是均摊下去的。

有趣的是，在改之前我的 test 代码可以在 1s 内跑完，但改成大根堆后代码需要跑 3s 多。理论上改成大根堆后维护的复杂度变成了 log 级别，应该显著优于改之前的。之所以出现这种与预期截然相反的情况，是因为 test 代码里只在一直加边，而改之前加边复杂度 $O(1)$，改之后复杂度变成了 $O(\log N)$，因此变慢了。这也反映了实际应用中，最坏时间复杂度有时并不能反映真实的运行时间情况。

### queryCoupleSum

直接遍历就行了，正是因为这个方法的存在，限制了 queryBestAcquaintance 方法的查询复杂度必须 $O(1)$。

### queryShortestPath

dfs 或者 bfs 都行。
