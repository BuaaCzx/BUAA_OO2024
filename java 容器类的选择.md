# java 容器类的选择

在面向对象设计的实现过程中，我们经常需要使用容器来存储和管理对象。而对于不同的对象及其需求（主要是增删改查），我们需要在设计时仔细分析利弊，选择合适的容器类来高效的管理对象、实现需求。

在第三单元的代码实现过程中，使用的最多的还是 HashMap，由于数据的特性，每个对象的 id 都是独一无二的，并且常常需要通过 id 来查询特定的对象。我们用 HashMap 来存储键值对，建立 id 到各种类型的对象的映射，以实现高效的查询。

本次作业新增了需要管理的 Message 对象，既然新增了对象，那么它作为 NetWork 和 Person 类的成员变量，需要在这两个类中选用合适的容器类进行管理。为了兼顾代码简洁性和时间复杂度，我在阅读 jml 的过程中便在仔细考量容器类的选用。不同于此前都是很快的确定下了 HashMap 的使用，这次，对于在 Person 类中管理 Message 对象，由于对于 Message 需要进行各种更加丰富的管理，我前后思考了很久，几经改动最终才选定了使用的容器。完成作业后，我认为这个思考的过程值得记录下来（主要是一边阅读 jml 的需求，随着需求的增加，脑子里想的容器也在随之改变，感觉这个过程很有趣？）。

我在阅读 jml 和实现接口的过程中，依照的是自底而上的实现思路，即先阅读最底层的 Message 类，然后是 Person 类，最后再是 Network 类。我认为这样可以帮我更好的了解 Message 对象的特性，结合特性理解需求，进而初步确定管理办法。

首先，阅读 Message 类的 jml。和其它类一样，每个 Message 对象都有一个独一无二的 id，这让我首先就想到了沿用 HashMap 来管理。

然后，阅读 Person 类的 jml。Person 类中新增的与 Message 相关的方法主要是 `getMessages` 和 `getReceivedMessages`。其中前者是返回当前 Person 里的所有 Message 对象，这个很好实现，不管用什么容器都可以很好的把它 get 出来；后者是返回 **前 5 个** Message，这个方法的出现表明，Message 是有一定顺序的，而且结合对于自然语言的感性理解，这大概率和消息的接收顺序有关，由于这个方法的出现，我们便不能使用无序的 HashMap 或 HashSet 来管理 Message 对象了。读完 Person 类的 jml 后，我有两种对 Message 类进行管理的想法：

1. 给 Message 新增一个成员变量表示优先级，然后用有序的 TreeSet 和 TreeMap 来管理。
2. 使用链式的 List 容器来管理。

最后，阅读 Network 类的 jml，这是最繁杂、需求最多的 jml，对于最后的选择也有着最大的影响。Network 类中对于 Network 类本身，有一些 add 和 get Message 的方法，在 Network 类中管理 Message 对象很自然的应该选用 HashMap。但是，Network 类的一些方法，对于 Person 类管理 Message 提出了更丰富的需求，涉及到的方法主要是 `sendMessage` 和 `clearNotices`。前者涉及在 Person 中增加 Message，值得注意的是会把 Message 加到容器的最前部；后者涉及在 Person 中删除 Message，且由于单次操作需要删除的 Message 对象可能有很多，所以删除操作复杂度需要做到 $O(1)$。由于群发消息的存在，因此这两个操作的复杂度都需要是 $O(1)$ 的（一次 send 中会使很多人都执行一次增加操作）。结合这两个需求，很容易发现选用链式的存储容器是最合适的，最终选用了 LinkedList 来管理。

具体实现上，增加操作使用 LinkedList 的 `addFirst` 方法；删除操作使用了 LinkedList 的 `removeIf` 方法。

值得注意的是，LinkedList 的 `remove` 方法，如果传进去的是对象，那么单次删除复杂度是 $O(N)$ 的（需要遍历列表找到对象）；如果传进去的是索引，那么单次删除复杂度是 $O(1)$ 的。因此，我最初的实现是，先遍历列表，记录所有需要删除的索引，然后倒序遍历需要删除的索引并依次调用 `remove` 方法（倒序遍历是为了使尚未删除的对象索引不变）。在和舍友的交流下发现，可以用迭代器实现一边遍历一边删除，这样 $O(N) $ 扫一遍就可以了，而阅读源码后发现这也是 LinkedList 的 `removeIf` 方法所使用的实现方式，因此直接调用 `removeIf` 方法就行了。这提醒我们，在实现的过程中，使用容器已经提供的方法，可以大大简化代码，并减小出错的可能性，但仍需要注意容器本身提供方法的复杂度，这往往可以通过问 ai 和网上搜索来获知，阅读源码实现也是一个很好的方法，并且了解标准库的实现也会让自己有所收获。
